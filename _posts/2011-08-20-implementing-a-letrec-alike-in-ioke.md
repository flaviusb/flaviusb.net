---
title: Implementing a letrec-alike in Ioke
tags:
- programming
- ioke
- code
---

So, some time ago I tried to demonstrate the Parser Combinator approach to parsing to a friend, with a simple JSON parser in Ioke. This parser would be built in two layers; a generic <code class="nc">Parser</code> object, with some basic combinators, and a <code class="nc">JSONParser</code> object with additional parsers for JSON. The simple parser was easy enough; <code class="nf">lit</code>, <code class="nf">alt</code>, <code class="nf">seq</code>, <code class="nf">star</code>, <code class="nf">many1</code>, <code class="nf">wrapped</code> etc were easy to define. Things became interesting when, for the JSON parser, I had definitions for <code class="nf">list</code> and <code class="nf">dict</code> which were mutually recursive. Theoretically, the <code class="k">with</code> construct should enable this; as it turns out, it seems to only work when all of the mutually recursive functions do not depend on anything further up the chain of mimics, and even then not reliably. So, I let it rest.

Half a year later I took a short holiday, and as often happens decided that a spot of yak shaving was called for. What I wanted was something similar to <code class="k">letrec</code> in Scheme; this was complicated by potential activateability, and the idea that a value might be a result of the activation of its definition; for example, many of the parsers are defined by combinators taking parsers as arguments, returning new parsers. The parsers must act as inactivateable, except when they are at the top level, when they must be activateable. The methods in the literature did not seem to handle this; they either seem to need function definitions to be totally declarative and references to cells to be completely late bound, or for simple lambda wrapping to work. So, after assuring myself that I wasn't ignoring the literature, I proceeded to write some code. In Ioke it is acceptable to make use of gratuitous mutation; so I took a decidedly kludgy approach and had the values wrap themselves in a macro which queried the environment to see whether they should be activateable, and if so, to replace the contents of their cell with the result of the invocation of their quoted definition, and then activate themselves. This is similar to the various lambda wrapping methods, with some extra heuristics and an implementation of quote-invoke-replace-invoke I haven't seen anywhere else[^1]. There are still several ways that this fails to give true simultaneous assignment; notably while the created object will respond to the appropriate message invocation to return/activate members, the members will both look different to introspection and not show up in some parts of the MOP (ie <code class="k">cellNames</code>, <code class="k">cells</code>) until they have been activated for the first time at the top level; also, anything that requires strictness due to side effects or dependance on transitory external state during the definition will obviously not work as intended.

Anyhow, here is the code I came up with:

<div class="code"><pre><code><span class="nc">DefaultBehavior</span> <span class="nb">FlowControl</span> <span class="nv">letrec</span> <span class="o">=</span> <span class="nf">macro</span><span class="p">(</span>
  <span class="ni">newObject</span> <span class="o">=</span> <span class="p">@</span><span class="k">mimic</span> 
  <span class="n">call</span> <span class="n">arguments</span> <span class="n">each</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> 
    <span class="kr">if</span><span class="p">(</span><span class="n">arg</span> <span class="n">keyword?</span><span class="p">,</span>
        <span class="nb">Reflector</span> <span class="n">other:cell</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arg</span> <span class="n">name</span> <span class="k">asText</span> <span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mf">-2</span><span class="p">])</span> <span class="o">=</span> <span class="p">(&#39;&#39;(</span><span class="nf">method</span><span class="p">(</span><span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="o">+</span><span class="ss">:b</span><span class="p">,</span>
          <span class="c">; Make inactivateable for the moment</span>
          <span class="kr">if</span><span class="p">(</span><span class="n">a</span> <span class="n">empty?</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="n">empty?</span><span class="p">,</span> <span class="kr">return</span> <span class="p">@@)</span>
          <span class="nb">Reflector</span> <span class="n">other:cell</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">&quot;</span><span class="p">#{`(</span><span class="n">arg</span> <span class="n">name</span> <span class="k">asText</span> <span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mf">-2</span><span class="p">])}</span><span class="s">&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="p">&#39;&#39;(`(</span><span class="n">arg</span> <span class="n">next</span><span class="p">))</span> <span class="n">evaluateOn</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
          <span class="nb">Reflector</span> <span class="n">other:send</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">&quot;</span><span class="p">#{`(</span><span class="n">arg</span> <span class="n">name</span> <span class="k">asText</span> <span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mf">-2</span><span class="p">])}</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span> <span class="n">b</span><span class="p">)))</span> <span class="n">evaluateOn</span><span class="p">(</span><span class="n">self</span><span class="p">)),</span> 
        <span class="nb">Reflector</span> <span class="n">other:send</span><span class="p">(</span><span class="n">newObject</span><span class="p">,</span> <span class="n">arg</span><span class="p">)))</span>
  <span class="n">newObject</span><span class="p">)</span></code></pre></div>

[^1]: Yes, the literature is substantial. Yes, I probably missed something. No, this is different from the various nil-placeholder-quote-replace implementations out there.
